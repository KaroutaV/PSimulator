import java.util.*;

public class EventList {

    private Queue<Packet> eventQueue;
    private int totalPackets;
    private int numberOfNodes;
    private Random random;

    public EventList(int numberOfNodes, int totalPackets) {
        this.numberOfNodes = numberOfNodes;
        this.totalPackets = totalPackets;
        this.eventQueue = new PriorityQueue<>((p1, p2) -> Double.compare(p1.getGeneratedTime(), p2.getGeneratedTime()));
        this.random = new Random();
    }

    /**
     * Generates data packets in a network simulation and adds them to the event queue.
     * The packets are generated in cycles, where each cycle has a specified duration.
     * The number of packets in each cycle follows a Poisson distribution based on
     * a third of the total available nodes.
     *
     * For each cycle:
     * - A random subset of nodes is selected to send packets.
     * - Each selected node sends one packet at a random time within the cycle duration.
     * - The packets are stored in the event queue for processing.
     *
     * The process continues until the total number of packets reaches {@code totalPackets}.
     */
    // Main method for generating packets
    public void generatePacketsWithPoissonDistribution(int cycleDuration) {
        int packetCount = 0;
        long cycleStartTime = 0; // Start time of the cycle

        // Continue generating packets until reaching the required total count
        while (packetCount < totalPackets) {
            // Determine the number of packets for this cycle using Poisson distribution
            int packetsPerCycle = (numberOfNodes > 1) ? boundedPoisson(numberOfNodes * 0.7, numberOfNodes) : 1; // Use Poisson distribution or 1 if only 1 node

//            System.out.println("Packet per cycle " + packetsPerCycle);
            Set<Integer> nodePerCycleSet = new HashSet<>(); // Set to track unique nodes per cycle

            // Generate packets from random unique nodes
            for (int i = 0; i < packetsPerCycle && packetCount < totalPackets; i++) {
                int nodeId;
                // Randomly select unique nodes for packet generation
                do {
                    nodeId = random.nextInt(numberOfNodes) + 1; // Select a random node
                } while (!nodePerCycleSet.add(nodeId)); // If node is already in the set, it won't be added again

                // Create a packet with a random time within the cycle
                Packet packet = new Packet(nodeId, cycleStartTime + random.nextInt(cycleDuration));
                eventQueue.add(packet);
                packetCount++;
            }

            // Move to the next cycle
            cycleStartTime += cycleDuration;
        }
    }
    public void generatePacketsWithPoissonDistribution(int cycleDuration, int interPacketInterval) {
        int packetCount = 0;
        long cycleStartTime = 0; // Start time of the cycle

        Set<Integer> nodes = new HashSet<>(); // Set to track unique nodes per cycle
        Set<Integer> nodesWithFirstPacket = new HashSet<>(); // Set to track nodes that have generated their first packet
        Map<Integer, Packet> nodePackets = new HashMap<>(); // Map to store the last packet generated by each node

        // Continue generating packets until all nodes have generated their first packet
        while (nodesWithFirstPacket.size() < numberOfNodes) {
            // Ensure that we generate enough packets to cover all nodes
            int packetsPerCycle = Math.min(boundedPoisson(numberOfNodes / 3.0, numberOfNodes), numberOfNodes);
            //System.out.println("Packets per cycle: " + packetsPerCycle);

            if (numberOfNodes == 1) {
                int nodeId = 1;
                // Generate a single packet for the single node
                Packet packet = new Packet(nodeId, cycleStartTime+ random.nextInt(cycleDuration));
                eventQueue.add(packet);
                nodePackets.put(nodeId, packet);
                nodesWithFirstPacket.add(nodeId);
                packetCount++;
//                System.out.println("Node " + nodeId + " generated its first packet.");
            } else {
                // Generate packets from random unique nodes
                for (int i = 0; i < packetsPerCycle && packetCount < totalPackets; i++) {
                    int nodeId;
                    // Randomly select unique nodes for packet generation
                    do {
                        nodeId = random.nextInt(numberOfNodes) + 1; // Select a random node
                    } while (!nodes.add(nodeId)); // If node is already in the set, it won't be added again

                    // Create a packet with a random time within the cycle
                    Packet packet = new Packet(nodeId, cycleStartTime + random.nextInt(cycleDuration));
                    eventQueue.add(packet);
                    nodePackets.put(nodeId, packet);
                    packetCount++;

                    // Add node to the set of nodes that have generated their first packet
                    nodesWithFirstPacket.add(nodeId);
                    //System.out.println("Node " + nodeId + " generated its first packet.");

                    // Debugging: print the current state of nodesWithFirstPacket
                    //System.out.println("Nodes with first packet: " + nodesWithFirstPacket);
                    if (packetCount == numberOfNodes) {
                        break;
                    }
                }

                // Debugging: print the sizes of the sets
//            System.out.println("Nodes size: " + nodes.size());
//            System.out.println("Nodes with first packet size: " + nodesWithFirstPacket.size());

                // Check if the total packet count is reached
                if (packetCount == numberOfNodes) {
                    break;
                }

                // Move to the next cycle
                cycleStartTime += cycleDuration;
            }
        }
//        System.out.println("All nodes have generated their first packet.");

        // After the Poisson-based packet generation, use the inter-packet interval for remaining packets
        long currentTime;
        while (packetCount < totalPackets) {
//            System.out.println("Generating remaining packets...");
            for (int nodeId = 1; nodeId <= numberOfNodes && packetCount < totalPackets; nodeId++) {
                // Get the last generated packet's time
                long lastTime = nodePackets.get(nodeId).getGeneratedTime();
                currentTime = lastTime + interPacketInterval; // Calculate the time for the next packet

                // Create a new packet with the calculated time
                Packet packet = new Packet(nodeId, currentTime);
                eventQueue.add(packet);
                nodePackets.put(nodeId, packet);
                packetCount++;
            }
        }
    }

    // Function to generate Poisson-distributed samples within the bounds [0, maxNodes]
    private int boundedPoisson(double lambda, int maxNodes) {
        int samples;
        int maxAttempts = 100;
        int attempts = 0;

        do {
            samples = poissonDistribution(lambda);
            attempts++;
        } while ((samples < 0 || samples > maxNodes) && attempts < maxAttempts);

        return (attempts < maxAttempts) ? samples : maxNodes;
    }

    // Poisson distribution function
    private int poissonDistribution(double lambda) {
        if (lambda <= 0) return 0;

        double l = Math.exp(-lambda);
        int k = 0;
        double p = 1.0;

        do {
            k++;
            p *= random.nextDouble();
        } while (p > l);

        return k - 1;
    }

    public void generatePacketsWithProbability(int cycleDuration, int loadPercentage) {
        if (loadPercentage < 10 || loadPercentage > 100) {
            throw new IllegalArgumentException("Load percentage must be between 10 and 100.");
        }

        int p = loadPercentage / 10; // Μετατροπή ποσοστού σε κλίμακα 1-10
        int packetCount = 0;
        long cycleStartTime = 0; // Ώρα έναρξης του κύκλου

        // Συνεχίζουμε να δημιουργούμε πακέτα μέχρι να φτάσουμε το συνολικό πλήθος
        while (packetCount < totalPackets) {
//            System.out.println("Cycle start: " + cycleStartTime + ", Total remaining packets: " + (totalPackets - packetCount));
            Set<Integer> nodePerCycleSet = new HashSet<>(); // Για να αποθηκεύουμε μοναδικά EDs ανά κύκλο

            for (int i = 0; i < numberOfNodes && packetCount < totalPackets; i++) {
                int randomValue = random.nextInt(10) + 1; // Παράγει τιμή [1,10]

                if (randomValue > p) {
                    // ED does not have a packet
//                    System.out.println("Node " + (i + 1) + " has no packet this cycle.");
                    continue;
                }

                // ED has a packet
                int nodeId = i + 1;
                if (!nodePerCycleSet.add(nodeId)) {
                    // Αν ο κόμβος έχει ήδη πακέτο σε αυτόν τον κύκλο, συνεχίζουμε στον επόμενο κόμβο
                    continue;
                }

                Packet packet = new Packet(nodeId, cycleStartTime + random.nextInt(cycleDuration)); // Δημιουργία πακέτου
                eventQueue.add(packet);
                packetCount++;

            }

            // Περνάμε στον επόμενο κύκλο
            cycleStartTime += cycleDuration;
        }
    }

    // print all the packets from the event list
    public void printEventList() {
        while (!eventQueue.isEmpty()) {
            Packet packet = eventQueue.poll();
//            System.out.println(packet);
            System.out.println("The end device with ID " + packet.getEndDeviceID() + " generated a packet at " + packet.getGeneratedTime() + " ms.");
        }
    }
    public void addSequenceNumber() {
        Queue<Packet> tempQueue = new LinkedList<>();
        while (!eventQueue.isEmpty()) {
            Packet packet = eventQueue.poll();
            packet.setSequenceNumber();
            tempQueue.add(packet);
        }
        eventQueue = tempQueue;

    }
    public boolean isEmpty(){
        return eventQueue.isEmpty();
    }
    public Packet pullPacketFromEventList(){
        return eventQueue.poll();
    }
    public void addPacketToEventList(Packet packet){ eventQueue.add(packet); }

    public Packet findPacketByNodeId(long nodeId) {
        Iterator<Packet> iterator = eventQueue.iterator();
        while (iterator.hasNext()) {
            Packet packet = iterator.next();
            if (packet.getEndDeviceID() == nodeId) {
                return packet;
            }
        }
        return null;
    }
    public void clearEventList(){
        eventQueue.clear();
    }

    public void copyEventList(EventList eventList){
        Packet packet ;
        while(!eventList.isEmpty()){
            packet = eventList.pullPacketFromEventList();
            this.addPacketToEventList(packet);
        }
    }
}
